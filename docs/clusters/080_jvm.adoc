///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Configure the Coherence JVM

== Configure the Coherence JVM

There are a number of fields in the `CoherenceCluster` CRD that can be used to configure the JVM.
These fields are all in the `jvm` section when configuring a `role` in the CRD.

* <<#args,JVM Arguments>>
* <<#gc,Garbage Collector Configuration>>
** <<#gc-collector,Configuring the Garbage Collector to Use>>
** <<#gc-args,Configuring the Garbage Collector Arguments>>
** <<#gc-logging,Configuring Garbage Collector Logging>>
* <<#memory,Memory Configuration>>
** <<#heap-size,Heap Size>>
** <<#metaspace-size,Metaspace size>>
** <<#stack-size,Stack size>>
** <<#nio-size,Native Memory Size>>
** <<#nmt,Native Memory Tracking>>
* <<#oom,Behaviour on Out Of Memory Error>>
* <<#useContainerLimits,Container Resource Limits>>
* <<#flightRecorder,Flight Recorder>>
* <<#diagnosticsVolume,Diagnostic Volume>>
* <<debug#,JVM Debug Arguments>>


// ----- JVM Arguments -------------------------------------------------------------------------------------------------
'''
[#args]
== JVM Arguments

The `jvm.args` field is a string array of arbitrary JVM options. Any valid JVM option or system property argument may be
passed to the JVM in the Coherence container by setting the value in this field.

A number of arguments are always passed to the JVMs that are part of the Coherence cluster:

```
-XX:HeapDumpPath=/jvm/${POD_NAME}/${POD_UID}/heap-dumps/${POD_NAME}-${POD_UID}.hprof  <1>
-XX:ErrorFile=/jvm/${POD_NAME}/${POD_UID}/hs-err-${POD_NAME}-${POD_UID}.log           <2>
-Dcoherence.ttl=0
-XshowSettings:all
-XX:+PrintCommandLineFlags
-XX:+PrintFlagsFinal
-XX:+UnlockDiagnosticVMOptions
-XX:+UnlockCommercialFeatures
-XX:+UnlockExperimentalVMOptions
```

<1> Any heap dumps created by the JVM when an out of memory error occurs will be written to a file called
`/jvm/${POD_NAME}/${POD_UID}/heap-dumps/${POD_NAME}-${POD_UID}.hprof`
<2> Any error files created by a JVM crash will be written to a file called
`/jvm/${POD_NAME}/${POD_UID}/hs-err-${POD_NAME}-${POD_UID}.log`

The `/jvm` root directory used for heap dumps and error files can be
<<#diagnosticsVolume,mounted to an external volume>> to allow easier access to these files.


=== Setting the JVM Arguments for the Implicit Role

When creating a `CoherenceCluster` with a single implicit role the `args` is set in the `spec.jvm` section of
the configuration. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  jvm:
    args:
      - "-XX:G1HeapRegionSize=16m"  # <1>
      - "-Dfoo=bar" 
----

<1> The `-XX:G1HeapRegionSize=16m` JVM option and the `-Dfoo=bar` system property will be passed as arguments to the 
JVM for the implicit storage role.


=== Setting the JVM Arguments for Explicit Roles

When creating a `CoherenceCluster` with one or more explicit roles the `args` are set in the `jvm` section of
the configuration for each `role` in the `roles` list. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  roles:
    - role: data
      jvm:
        args:
          - "-XX:G1HeapRegionSize=16m"  # <1>
          - "-Dcoherence.pof.config=storage-pof-config.xml"
    - role: proxy
      jvm:
        args:
          - "-XX:MaxGCPauseMillis=500"  # <2>
          - "-Dcoherence.pof.config=proxy-pof-config.xml"
----

<1> The `-XX:G1HeapRegionSize=16m -Dcoherence.pof.config=storage-pof-config.xml` arguments will be passed to the JVM for
the explicit `data` role.
<2> The `-XX:MaxGCPauseMillis=500 coherence.pof.config=proxy-pof-config.xml` argument will be passed to the JVM for the
explicit `proxy` role.


=== Setting the JVM Arguments for Explicit Roles with a Default

When creating a `CoherenceCluster` with one or more explicit roles a default `args` value can be set in the
`CoherenceCluster` `spec` section that will apply to all of the roles in the `roles` list. Any `args` set explicitly
in the `jvm.args` field for a `role` will be *merged* with those in the defaults section. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  jvm:
    args:
      - "-XX:MaxGCPauseMillis=500"  # <1>
      - "-XX:G1HeapRegionSize=16m" 
  roles:
    - role: data                    # <2>
      jvm:
        args:
          - "-XX:+AggressiveHeap"
    - role: proxy                   # <3>
----

<1> The default JVM `args` of `-XX:MaxGCPauseMillis=500` and `-XX:G1HeapRegionSize=16m` will be passed to the JVM
for *all* roles.
<2> The `data` role adds an additional argument `-XX:+AggressiveHeap` so the JVM will be passed three arguments:
`-XX:MaxGCPauseMillis=500 -XX:G1HeapRegionSize=16m -XX:+AggressiveHeap`
<3> The `proxy` role does not specify any additional args so will just use the two default JVM arguments
`-XX:MaxGCPauseMillis=500 -XX:G1HeapRegionSize=16m`


// ----- Garbage Collector Configuration -------------------------------------------------------------------------------
'''
[#gc]
== Garbage Collector Configuration

The `CoherenceCluster` CRD allows garbage collector settings to be applied to the Coherence JVMs. Whilst any GC
parameters could actually be applied using the `jvm.args` field these GC specific fields allow options to be set
without having to look up and remember specific GC options.

* <<#gc-collector,Configuring the Garbage Collector to Use>>
* <<#gc-args,Configuring the Garbage Collector Arguments>>
* <<#gc-logging,Configuring Garbage Collector Logging>>

// ----- Garbage Collector ---------------------------------------------------------------------------------------------

[#gc-collector]
=== Configuring the Garbage Collector to Use

The `CoherenceCluster` CRD supports setting the garbage collectors to use automatically. The supported collectors are
G1, CMS or Parallel or the JVM default.


// ----- Garbage Collector Arguments -----------------------------------------------------------------------------------

[#gc-args]
=== Configuring Garbage Collector Arguments


// ----- Garbage Collector Logging -------------------------------------------------------------------------------------

[#gc-logging]
=== Configuring Garbage Collector Logging


// ----- Memory Configuration ------------------------------------------------------------------------------------------
'''
[#memory]
== Memory Configuration

The JVM has a number of options that can be set to fix the size of different memory regions. The `CoherenceCluster` CRD
provides fields to set that most common values. None of these fields have default values so if they are not specified
the JVMs default behaviour will apply.

The memory options that can be configured are:

* <<#heap-size,Heap Size>>
* <<#metaspace-size,Metaspace size>>
* <<#stack-size,Stack size>>
* <<#nio-size,Max Native Memory>>
* <<#nmt,Native Memory Tracking>>
* <<#oom,Behaviour on Out Of Memory Error>>

NOTE: If the `Pod` resource limits are being set to limit memory usage of a `Pod` it is recommended that some of the JVM
memory regions are fixed to ensure that the JVM does not exceed the container's resource limits in a JVM before Java 10.
Prior to Java 10 the JVM could see all of the memory available to a machine regardless of any Pod limits.
The JVM could then easily attempt to consume more memory that the `Pod` or `Container` was allowed and consequently
crashing the `Pod`. With Coherence images that use a version of Java above 10 this issue is less of a problem.
Even so if using the `resources` section of the configuration to limit a `Pod` or `Containers` memory it is a good idea
to limit the JVM heap. Also see <<#useContainerLimits,the useContainerLimits setting>>.


// ----- Heap Size -----------------------------------------------------------------------------------------------------

[#heap-size]
=== JVM Heap Size

It is good practice to fix the Coherence JVM heap size and to set both the JVM `-Xmx` and `-Xms` options to the same
value.
The heap size of the JVM can be configured for roles in the `jvm.heapSize` field of a role spec. If the `heapSize` value
is configured then that value is applied to bot the JVMs minimum and maximum heap sizes (i.e. used to set both
`-Xms` and -`Xmx`).

The format of the value of the `heapSize` field is any valid value that can be used when setting the `-Xmx` JVM option,
for example `10G` would set a 10 GB heap.

==== Setting the JVM Heap Size for the Implicit Role

When creating a `CoherenceCluster` with a single implicit role the `heapSize` is set in the `spec.jvm` section of
the configuration. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  jvm:
    memory:
      heapSize: 10g <1>
----

<1> The Coherence JVM for the implicit role defined above will have a 10 GB heap.
Equivalent to passing `-Xms10g -Xmx10g` to the JVM.


==== Setting the JVM Heap Size for Explicit Roles

When creating a `CoherenceCluster` with one or more explicit roles the `heapSize` is set in the `jvm` section of
the configuration for each `role` in the `roles` list. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  roles:
    - role: data
      jvm:
        memory:
          heapSize: 10g  <1>
    - role: proxy
      jvm:
        memory:
          heapSize: 500m <2>
----

<1> The Coherence JVM for the `data` role defined above will have a 10 GB heap.
Equivalent to passing `-Xms10g -Xmx10g` to the JVM.
<2> The Coherence JVM for the `proxy` role defined above will have a 500 MB heap.
Equivalent to passing `-Xms500m -Xmx500m` to the JVM.


==== Setting the JVM Heap Size for Explicit Roles with a Default

When creating a `CoherenceCluster` with one or more explicit roles a default `heapSize` value can be set in the
`CoherenceCluster` `spec` section that will apply to all of the roles in the `roles` list unless specifically
overridden by a role's `jvm.heapSize` field. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  jvm:
    heapSize: 500m      <1>
  roles:
    - role: data
      jvm:
        memory:
          heapSize: 10g <2>
    - role: proxy       <3>
    - role: web         <4>
----

<1> The default max heap size of 500 MB will be applied to all of the roles in the cluster unless overridden for a
specific role.
<2> The `data` role overrides the default value to set the max heap for all JVMs in the `data` role to 10 GB.
Equivalent to passing `-Xms10g -Xmx10g` to the JVM.
<3> The `proxy` role does not specify a `heapSize` value so it will use the default value of 500 MB.
<4> The `web` role does not specify a `heapSize` value so it will use the default value of 500 MB.


// ----- Metaspace Size ------------------------------------------------------------------------------------------------

[#metaspace-size]
=== JVM Metaspace Size


// ----- Stack Size ----------------------------------------------------------------------------------------------------

[#stack-size]
=== JVM Stack Size


// ----- Stack Size ----------------------------------------------------------------------------------------------------

[#nio-size]
=== JVM Native Memory Size


// ----- Stack Size ----------------------------------------------------------------------------------------------------

[#nmt]
=== Native Memory Tracking

See the JVM https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html[native memory tracking]
documentation.


// ----- JVM OOM Behavior ----------------------------------------------------------------------------------------------

[#oom]
=== JVM Behaviour on Out Of Memory




// ----- Use Container Limits ------------------------------------------------------------------------------------------
'''
[#useContainerLimits]
== Container Resource Limits

When running JVMs inside containers it is recommended to configure the JVM to respect the memory and CPU resource limits
that are configured for the container. This is especially important in Kubernetes where the `Pod` may be terminated if a
container exceeds the configured resource limits. The `jvm.useContainerLimits` field is used to either add or omit the
`-XX:+UseContainerSupport` JVM argument. If `useContainerLimits` is set to `true` then `-XX:+UseContainerSupport` is
added to the JVM arguments, if `useContainerLimits` is set to `false` then `-XX:+UseContainerSupport` is not
added to the JVM arguments.

The default value of `useContainerLimits` if not specified is `true` so `-XX:+UseContainerSupport` will always be added
to the JVM arguments unless `useContainerLimits` is explicitly set to `false`. It is recommended that this value be left
unspecified as the default `true` unless other arguments are being passed to the JVM to limit its resource usage.

=== Setting Container Resource Limits for the Implicit Role

When creating a `CoherenceCluster` with a single implicit role the `useContainerLimits` is set in the `spec.jvm`
section of the configuration. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  jvm:
    useContainerLimits: true  # <1>
----

<1> The `-XX:+UseContainerSupport` JVM option will be passed as arguments to the JVM for the implicit storage role.


=== Setting Container Resource Limits for Explicit Roles

When creating a `CoherenceCluster` with one or more explicit roles the `useContainerLimits` are set in the `jvm`
section of the configuration for each `role` in the `roles` list. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  roles:
    - role: data
      jvm:
        useContainerLimits: true  # <1>
    - role: proxy
      jvm:
        useContainerLimits: false  # <2>
----

<1> The `-XX:+UseContainerSupport` JVM option will be passed as arguments to the JVM for the explicit `data` role.
<2> The `-XX:+UseContainerSupport` JVM option will not be passed as arguments to the JVM for the explicit `proxy` role.


=== Setting Container Resource Limits for Explicit Roles with a Default

When creating a `CoherenceCluster` with one or more explicit roles a default `useContainerLimits` value can be set in
the `CoherenceCluster` `spec` section that will apply to all of the roles in the `roles` list unless explicitly
overridden for a role. For example:

[source,yaml]
----
apiVersion: coherence.oracle.com/v1
kind: CoherenceCluster
metadata:
  name: test-cluster
spec:
  jvm:
    useContainerLimits: true        # <1>
  roles:
    - role: data                    # <2>
      jvm:
        useContainerLimits: false
    - role: proxy                   # <3>
----

<1> The default `useContainerLimits` is set to `true`.
<2> The `data` role overrides the default `useContainerLimits` and sets it to `false`.
<3> The `proxy` role does not specify any `useContainerLimits` value so will use the default of `true`.


// ----- Flight Recorder -----------------------------------------------------------------------------------------------
'''
[#flightRecorder]
== Flight Recorder

Flight Recorder is a useful tool to use when diagnosing issues with a Coherence application or as an aid to performance
and GC tuning. By default the JVMs in a `CoherenceCluster` are configured to produce a continual flight recording that
will be dumped to a file when the JVM exits.

The `/jvm` root directory used for `.jfr` files can be <<#diagnosticsVolume,mounted to an external volume>> to allow
easier access to these files.


// ----- Diagnostic Volume ---------------------------------------------------------------------------------------------
'''
[#diagnosticsVolume]
== Diagnostic Volume

By default the Coherence JVMs are configured to write heap dumps, error logs and flight recordings to directories in the
container under the root `/jvm` directory. The `/jvm` directory is mapped to `volumeMount` named `jvm` which is in turn
mapped to a `volume` named `jvm`.

The default configuration for the `jvm` volume is an empty directory.
```
- name: jvm
    emptyDir: {}
```

This default may be changed to map the `jvm` volume to any supported
https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes[Kubernetes `VolumeSource`].


// ----- JVM Debug Arguments -------------------------------------------------------------------------------------------

[#debug]
== JVM Debug Arguments