// +build !

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1

import (
	spec "github.com/go-openapi/spec"
	common "k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"./pkg/apis/coherence/v1.ApplicationSpec":         schema_pkg_apis_coherence_v1_ApplicationSpec(ref),
		"./pkg/apis/coherence/v1.CoherenceCluster":        schema_pkg_apis_coherence_v1_CoherenceCluster(ref),
		"./pkg/apis/coherence/v1.CoherenceClusterSpec":    schema_pkg_apis_coherence_v1_CoherenceClusterSpec(ref),
		"./pkg/apis/coherence/v1.CoherenceClusterStatus":  schema_pkg_apis_coherence_v1_CoherenceClusterStatus(ref),
		"./pkg/apis/coherence/v1.CoherenceInternal":       schema_pkg_apis_coherence_v1_CoherenceInternal(ref),
		"./pkg/apis/coherence/v1.CoherenceInternalSpec":   schema_pkg_apis_coherence_v1_CoherenceInternalSpec(ref),
		"./pkg/apis/coherence/v1.CoherenceInternalStatus": schema_pkg_apis_coherence_v1_CoherenceInternalStatus(ref),
		"./pkg/apis/coherence/v1.CoherenceRole":           schema_pkg_apis_coherence_v1_CoherenceRole(ref),
		"./pkg/apis/coherence/v1.CoherenceRoleSpec":       schema_pkg_apis_coherence_v1_CoherenceRoleSpec(ref),
		"./pkg/apis/coherence/v1.CoherenceRoleStatus":     schema_pkg_apis_coherence_v1_CoherenceRoleStatus(ref),
		"./pkg/apis/coherence/v1.CoherenceSpec":           schema_pkg_apis_coherence_v1_CoherenceSpec(ref),
		"./pkg/apis/coherence/v1.FluentdSpec":             schema_pkg_apis_coherence_v1_FluentdSpec(ref),
		"./pkg/apis/coherence/v1.ImageSpec":               schema_pkg_apis_coherence_v1_ImageSpec(ref),
		"./pkg/apis/coherence/v1.JVMSpec":                 schema_pkg_apis_coherence_v1_JVMSpec(ref),
		"./pkg/apis/coherence/v1.JvmDebugSpec":            schema_pkg_apis_coherence_v1_JvmDebugSpec(ref),
		"./pkg/apis/coherence/v1.LoggingSpec":             schema_pkg_apis_coherence_v1_LoggingSpec(ref),
		"./pkg/apis/coherence/v1.NamedPortSpec":           schema_pkg_apis_coherence_v1_NamedPortSpec(ref),
		"./pkg/apis/coherence/v1.PersistentStorageSpec":   schema_pkg_apis_coherence_v1_PersistentStorageSpec(ref),
		"./pkg/apis/coherence/v1.PortSpec":                schema_pkg_apis_coherence_v1_PortSpec(ref),
		"./pkg/apis/coherence/v1.PortSpecWithSSL":         schema_pkg_apis_coherence_v1_PortSpecWithSSL(ref),
		"./pkg/apis/coherence/v1.ReadinessProbeSpec":      schema_pkg_apis_coherence_v1_ReadinessProbeSpec(ref),
		"./pkg/apis/coherence/v1.SSLSpec":                 schema_pkg_apis_coherence_v1_SSLSpec(ref),
		"./pkg/apis/coherence/v1.ScalingProbe":            schema_pkg_apis_coherence_v1_ScalingProbe(ref),
		"./pkg/apis/coherence/v1.ServiceSpec":             schema_pkg_apis_coherence_v1_ServiceSpec(ref),
	}
}

func schema_pkg_apis_coherence_v1_ApplicationSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "The specification of the application deployed into the Coherence role members.",
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "The application type to execute. This field would be set if using the Coherence Graal image and running a none-Java application. For example if the application was a Node application this field would be set to \"node\". The default is to run a plain Java application.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"main": {
						SchemaProps: spec.SchemaProps{
							Description: "Class is the Coherence container main class.  The default value is com.tangosol.net.DefaultCacheServer. If the application type is non-Java this would be the name of the corresponding language specific runnable, for example if the application type is \"node\" the main may be a Javascript file.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"args": {
						SchemaProps: spec.SchemaProps{
							Description: "Args is the optional arguments to pass to the main class.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"appDir": {
						SchemaProps: spec.SchemaProps{
							Description: "The application folder in the custom artifacts Docker image containing application artifacts. This will effectively become the working directory of the Coherence container. If not set the application directory default value is \"/app\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"libDir": {
						SchemaProps: spec.SchemaProps{
							Description: "The folder in the custom artifacts Docker image containing jar files to be added to the classpath of the Coherence container. If not set the lib directory default value is \"/app/lib\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configDir": {
						SchemaProps: spec.SchemaProps{
							Description: "The folder in the custom artifacts Docker image containing configuration files to be added to the classpath of the Coherence container. If not set the config directory default value is \"/app/conf\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceCluster(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceCluster is the Schema for the coherenceclusters API",
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/coherence/v1.CoherenceClusterSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/coherence/v1.CoherenceClusterStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.CoherenceClusterSpec", "./pkg/apis/coherence/v1.CoherenceClusterStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceClusterSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceClusterSpec defines the desired state of CoherenceCluster",
				Properties: map[string]spec.Schema{
					"imagePullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/coherence/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "The name to use for the service account to use when RBAC is enabled The role bindings must already have been created as this chart does not create them it just sets the serviceAccountName value in the Pod spec.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether or not to auto-mount the Kubernetes API credentials for a service account",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"operatorRequestTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "The timeout to apply to rest requests made back to the operator from Coherence Pods.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"role": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of this role. This value will be used to set the Coherence role property for all members of this role",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of cluster members of this role. This is a pointer to distinguish between explicit zero and not specified. Default value is 3.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"application": {
						SchemaProps: spec.SchemaProps{
							Description: "The optional application definition",
							Ref:         ref("./pkg/apis/coherence/v1.ApplicationSpec"),
						},
					},
					"coherence": {
						SchemaProps: spec.SchemaProps{
							Description: "The optional application definition",
							Ref:         ref("./pkg/apis/coherence/v1.CoherenceSpec"),
						},
					},
					"coherenceUtils": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration for the Coherence utils image",
							Ref:         ref("./pkg/apis/coherence/v1.ImageSpec"),
						},
					},
					"logging": {
						SchemaProps: spec.SchemaProps{
							Description: "Logging allows configuration of Coherence and java util logging.",
							Ref:         ref("./pkg/apis/coherence/v1.LoggingSpec"),
						},
					},
					"jvm": {
						SchemaProps: spec.SchemaProps{
							Description: "The JVM specific options",
							Ref:         ref("./pkg/apis/coherence/v1.JVMSpec"),
						},
					},
					"ports": {
						SchemaProps: spec.SchemaProps{
							Description: "Ports specifies additional port mappings for the Pod and additional Services for those ports",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/coherence/v1.NamedPortSpec"),
									},
								},
							},
						},
					},
					"env": {
						SchemaProps: spec.SchemaProps{
							Description: "Env is additional environment variable mappings that will be passed to the Coherence container in the Pod To specify extra variables add them as name value pairs the same as they would be added to a Pod containers spec, for example these values:\n\nenv:\n  - name \"FOO\"\n    value: \"foo-value\"\n  - name: \"BAR\"\n    value \"bar-value\"\n\nwill add the environment variable mappings FOO=\"foo-value\" and BAR=\"bar-value\"",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"healthPort": {
						SchemaProps: spec.SchemaProps{
							Description: "The port that the health check endpoint will bind to.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "The readiness probe config to be used for the Pods in this role. ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/",
							Ref:         ref("./pkg/apis/coherence/v1.ReadinessProbeSpec"),
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "The liveness probe config to be used for the Pods in this role. ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/",
							Ref:         ref("./pkg/apis/coherence/v1.ReadinessProbeSpec"),
						},
					},
					"scaling": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration to control safe scaling.",
							Ref:         ref("./pkg/apis/coherence/v1.ScalingSpec"),
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources is the optional resource requests and limits for the containers\n ref: http://kubernetes.io/docs/user-guide/compute-resources/\n\nBy default the cpu requests is set to zero and the cpu limit set to 32. This is because it appears that K8s defaults cpu to one and since Java 10 the JVM now correctly picks up cgroup cpu limits then the JVM will only see one cpu. By setting resources.requests.cpu=0 and resources.limits.cpu=32 it ensures that the JVM will see the either the number of cpus on the host if this is <= 32 or the JVM will see 32 cpus if the host has > 32 cpus. The limit is set to zero so that there is no hard-limit applied.\n\nNo default memory limits are applied.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations are free-form yaml that will be added to the store release as annotations Any annotations should be placed BELOW this annotations: key. For example if we wanted to include annotations for Prometheus it would look like this:\n\nannotations:\n  prometheus.io/scrape: \"true\"\n  prometheus.io/port: \"2408\"",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "The extra labels to add to the all of the Pods in this roles. Labels here will add to or override those defined for the cluster. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"volumes": {
						SchemaProps: spec.SchemaProps{
							Description: "Volumes defines extra volume mappings that will be added to the Coherence Pod.\n  The content of this yaml should match the normal k8s volumes section of a Pod definition\n  as described in https://kubernetes.io/docs/concepts/storage/volumes/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeClaimTemplates": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaimTemplates defines extra PVC mappings that will be added to the Coherence Pod.\n  The content of this yaml should match the normal k8s volumeClaimTemplates section of a Pod definition\n  as described in https://kubernetes.io/docs/concepts/storage/persistent-volumes/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.PersistentVolumeClaim"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeMounts defines extra volume mounts to map to the additional volumes or PVCs declared above\n  in store.volumes and store.volumeClaimTemplates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "Affinity controls Pod scheduling preferences.\n  ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is the Node labels for pod assignment\n  ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "Tolerations is for nodes that have taints on them.\n  Useful if you want to dedicate nodes to just run the coherence container\nFor example:\n  tolerations:\n  - key: \"key\"\n    operator: \"Equal\"\n    value: \"value\"\n    effect: \"NoSchedule\"\n\n  ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"roles": {
						SchemaProps: spec.SchemaProps{
							Description: "Roles is the list of different roles in the cluster There must be at least one role in a cluster.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/coherence/v1.CoherenceRoleSpec"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.ApplicationSpec", "./pkg/apis/coherence/v1.CoherenceRoleSpec", "./pkg/apis/coherence/v1.CoherenceSpec", "./pkg/apis/coherence/v1.ImageSpec", "./pkg/apis/coherence/v1.JVMSpec", "./pkg/apis/coherence/v1.LocalObjectReference", "./pkg/apis/coherence/v1.LoggingSpec", "./pkg/apis/coherence/v1.NamedPortSpec", "./pkg/apis/coherence/v1.ReadinessProbeSpec", "./pkg/apis/coherence/v1.ScalingSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.PersistentVolumeClaim", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceClusterStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceClusterStatus defines the observed state of CoherenceCluster",
				Properties: map[string]spec.Schema{
					"roles": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of roles in this cluster",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceInternal(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceInternal is the Schema for the coherenceinternal API",
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec contains the specification for a Coherence cluster. The format is the same as the values file for the Coherence Helm chart.",
							Ref:         ref("./pkg/apis/coherence/v1.CoherenceInternalSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/coherence/v1.CoherenceInternalStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.CoherenceInternalSpec", "./pkg/apis/coherence/v1.CoherenceInternalStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceInternalSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceInternalSpec defines the desired state of CoherenceInternal",
				Properties: map[string]spec.Schema{
					"fullnameOverride": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"nameOverride": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"cluster": {
						SchemaProps: spec.SchemaProps{
							Description: "The cluster name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"wka": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of the headless service used for Coherence WKA",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "The name to use for the service account to use when RBAC is enabled The role bindings must already have been created as this chart does not create them it just sets the serviceAccountName value in the Pod spec.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether or not to auto-mount the Kubernetes API credentials for a service account",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"imagePullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/coherence/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"operatorRequestTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "The timeout to apply to rest requests made back to the operator from Coherence Pods.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"role": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of this role. This value will be used to set the Coherence role property for all members of this role",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of cluster members of this role. This is a pointer to distinguish between explicit zero and not specified. Default value is 3.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"application": {
						SchemaProps: spec.SchemaProps{
							Description: "The optional application definition",
							Ref:         ref("./pkg/apis/coherence/v1.ApplicationSpec"),
						},
					},
					"coherence": {
						SchemaProps: spec.SchemaProps{
							Description: "The optional application definition",
							Ref:         ref("./pkg/apis/coherence/v1.CoherenceSpec"),
						},
					},
					"coherenceUtils": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration for the Coherence utils image",
							Ref:         ref("./pkg/apis/coherence/v1.ImageSpec"),
						},
					},
					"logging": {
						SchemaProps: spec.SchemaProps{
							Description: "Logging allows configuration of Coherence and java util logging.",
							Ref:         ref("./pkg/apis/coherence/v1.LoggingSpec"),
						},
					},
					"jvm": {
						SchemaProps: spec.SchemaProps{
							Description: "The JVM specific options",
							Ref:         ref("./pkg/apis/coherence/v1.JVMSpec"),
						},
					},
					"ports": {
						SchemaProps: spec.SchemaProps{
							Description: "Ports specifies additional port mappings for the Pod and additional Services for those ports",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/coherence/v1.NamedPortSpec"),
									},
								},
							},
						},
					},
					"env": {
						SchemaProps: spec.SchemaProps{
							Description: "Env is additional environment variable mappings that will be passed to the Coherence container in the Pod To specify extra variables add them as name value pairs the same as they would be added to a Pod containers spec, for example these values:\n\nenv:\n  - name \"FOO\"\n    value: \"foo-value\"\n  - name: \"BAR\"\n    value \"bar-value\"\n\nwill add the environment variable mappings FOO=\"foo-value\" and BAR=\"bar-value\"",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"healthPort": {
						SchemaProps: spec.SchemaProps{
							Description: "The port that the health check endpoint will bind to.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "The readiness probe config to be used for the Pods in this role. ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/",
							Ref:         ref("./pkg/apis/coherence/v1.ReadinessProbeSpec"),
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "The liveness probe config to be used for the Pods in this role. ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/",
							Ref:         ref("./pkg/apis/coherence/v1.ReadinessProbeSpec"),
						},
					},
					"scaling": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration to control safe scaling.",
							Ref:         ref("./pkg/apis/coherence/v1.ScalingSpec"),
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources is the optional resource requests and limits for the containers\n ref: http://kubernetes.io/docs/user-guide/compute-resources/\n\nBy default the cpu requests is set to zero and the cpu limit set to 32. This is because it appears that K8s defaults cpu to one and since Java 10 the JVM now correctly picks up cgroup cpu limits then the JVM will only see one cpu. By setting resources.requests.cpu=0 and resources.limits.cpu=32 it ensures that the JVM will see the either the number of cpus on the host if this is <= 32 or the JVM will see 32 cpus if the host has > 32 cpus. The limit is set to zero so that there is no hard-limit applied.\n\nNo default memory limits are applied.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations are free-form yaml that will be added to the store release as annotations Any annotations should be placed BELOW this annotations: key. For example if we wanted to include annotations for Prometheus it would look like this:\n\nannotations:\n  prometheus.io/scrape: \"true\"\n  prometheus.io/port: \"2408\"",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "The extra labels to add to the all of the Pods in this roles. Labels here will add to or override those defined for the cluster. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"volumes": {
						SchemaProps: spec.SchemaProps{
							Description: "Volumes defines extra volume mappings that will be added to the Coherence Pod.\n  The content of this yaml should match the normal k8s volumes section of a Pod definition\n  as described in https://kubernetes.io/docs/concepts/storage/volumes/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeClaimTemplates": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaimTemplates defines extra PVC mappings that will be added to the Coherence Pod.\n  The content of this yaml should match the normal k8s volumeClaimTemplates section of a Pod definition\n  as described in https://kubernetes.io/docs/concepts/storage/persistent-volumes/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.PersistentVolumeClaim"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeMounts defines extra volume mounts to map to the additional volumes or PVCs declared above\n  in store.volumes and store.volumeClaimTemplates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "Affinity controls Pod scheduling preferences.\n  ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is the Node labels for pod assignment\n  ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "Tolerations is for nodes that have taints on them.\n  Useful if you want to dedicate nodes to just run the coherence container\nFor example:\n  tolerations:\n  - key: \"key\"\n    operator: \"Equal\"\n    value: \"value\"\n    effect: \"NoSchedule\"\n\n  ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
				},
				Required: []string{"cluster"},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.ApplicationSpec", "./pkg/apis/coherence/v1.CoherenceSpec", "./pkg/apis/coherence/v1.ImageSpec", "./pkg/apis/coherence/v1.JVMSpec", "./pkg/apis/coherence/v1.LocalObjectReference", "./pkg/apis/coherence/v1.LoggingSpec", "./pkg/apis/coherence/v1.NamedPortSpec", "./pkg/apis/coherence/v1.ReadinessProbeSpec", "./pkg/apis/coherence/v1.ScalingSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.PersistentVolumeClaim", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceInternalStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceInternalStatus defines the observed state of CoherenceInternal",
				Properties:  map[string]spec.Schema{},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceRole(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceRole is the Schema for the coherenceroles API",
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/coherence/v1.CoherenceRoleSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("./pkg/apis/coherence/v1.CoherenceRoleStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.CoherenceRoleSpec", "./pkg/apis/coherence/v1.CoherenceRoleStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceRoleSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceRoleSpec defines a role in a Coherence cluster. A role is one or more Pods that perform the same functionality, for example storage members.",
				Properties: map[string]spec.Schema{
					"role": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of this role. This value will be used to set the Coherence role property for all members of this role",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of cluster members of this role. This is a pointer to distinguish between explicit zero and not specified. Default value is 3.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"application": {
						SchemaProps: spec.SchemaProps{
							Description: "The optional application definition",
							Ref:         ref("./pkg/apis/coherence/v1.ApplicationSpec"),
						},
					},
					"coherence": {
						SchemaProps: spec.SchemaProps{
							Description: "The optional application definition",
							Ref:         ref("./pkg/apis/coherence/v1.CoherenceSpec"),
						},
					},
					"coherenceUtils": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration for the Coherence utils image",
							Ref:         ref("./pkg/apis/coherence/v1.ImageSpec"),
						},
					},
					"logging": {
						SchemaProps: spec.SchemaProps{
							Description: "Logging allows configuration of Coherence and java util logging.",
							Ref:         ref("./pkg/apis/coherence/v1.LoggingSpec"),
						},
					},
					"jvm": {
						SchemaProps: spec.SchemaProps{
							Description: "The JVM specific options",
							Ref:         ref("./pkg/apis/coherence/v1.JVMSpec"),
						},
					},
					"ports": {
						SchemaProps: spec.SchemaProps{
							Description: "Ports specifies additional port mappings for the Pod and additional Services for those ports",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("./pkg/apis/coherence/v1.NamedPortSpec"),
									},
								},
							},
						},
					},
					"env": {
						SchemaProps: spec.SchemaProps{
							Description: "Env is additional environment variable mappings that will be passed to the Coherence container in the Pod To specify extra variables add them as name value pairs the same as they would be added to a Pod containers spec, for example these values:\n\nenv:\n  - name \"FOO\"\n    value: \"foo-value\"\n  - name: \"BAR\"\n    value \"bar-value\"\n\nwill add the environment variable mappings FOO=\"foo-value\" and BAR=\"bar-value\"",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"healthPort": {
						SchemaProps: spec.SchemaProps{
							Description: "The port that the health check endpoint will bind to.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "The readiness probe config to be used for the Pods in this role. ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/",
							Ref:         ref("./pkg/apis/coherence/v1.ReadinessProbeSpec"),
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "The liveness probe config to be used for the Pods in this role. ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/",
							Ref:         ref("./pkg/apis/coherence/v1.ReadinessProbeSpec"),
						},
					},
					"scaling": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration to control safe scaling.",
							Ref:         ref("./pkg/apis/coherence/v1.ScalingSpec"),
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources is the optional resource requests and limits for the containers\n ref: http://kubernetes.io/docs/user-guide/compute-resources/\n\nBy default the cpu requests is set to zero and the cpu limit set to 32. This is because it appears that K8s defaults cpu to one and since Java 10 the JVM now correctly picks up cgroup cpu limits then the JVM will only see one cpu. By setting resources.requests.cpu=0 and resources.limits.cpu=32 it ensures that the JVM will see the either the number of cpus on the host if this is <= 32 or the JVM will see 32 cpus if the host has > 32 cpus. The limit is set to zero so that there is no hard-limit applied.\n\nNo default memory limits are applied.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations are free-form yaml that will be added to the store release as annotations Any annotations should be placed BELOW this annotations: key. For example if we wanted to include annotations for Prometheus it would look like this:\n\nannotations:\n  prometheus.io/scrape: \"true\"\n  prometheus.io/port: \"2408\"",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "The extra labels to add to the all of the Pods in this roles. Labels here will add to or override those defined for the cluster. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"volumes": {
						SchemaProps: spec.SchemaProps{
							Description: "Volumes defines extra volume mappings that will be added to the Coherence Pod.\n  The content of this yaml should match the normal k8s volumes section of a Pod definition\n  as described in https://kubernetes.io/docs/concepts/storage/volumes/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeClaimTemplates": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaimTemplates defines extra PVC mappings that will be added to the Coherence Pod.\n  The content of this yaml should match the normal k8s volumeClaimTemplates section of a Pod definition\n  as described in https://kubernetes.io/docs/concepts/storage/persistent-volumes/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.PersistentVolumeClaim"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeMounts defines extra volume mounts to map to the additional volumes or PVCs declared above\n  in store.volumes and store.volumeClaimTemplates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "Affinity controls Pod scheduling preferences.\n  ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is the Node labels for pod assignment\n  ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "Tolerations is for nodes that have taints on them.\n  Useful if you want to dedicate nodes to just run the coherence container\nFor example:\n  tolerations:\n  - key: \"key\"\n    operator: \"Equal\"\n    value: \"value\"\n    effect: \"NoSchedule\"\n\n  ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.ApplicationSpec", "./pkg/apis/coherence/v1.CoherenceSpec", "./pkg/apis/coherence/v1.ImageSpec", "./pkg/apis/coherence/v1.JVMSpec", "./pkg/apis/coherence/v1.LoggingSpec", "./pkg/apis/coherence/v1.NamedPortSpec", "./pkg/apis/coherence/v1.ReadinessProbeSpec", "./pkg/apis/coherence/v1.ScalingSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.PersistentVolumeClaim", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceRoleStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceRoleStatus defines the observed state of CoherenceRole",
				Properties: map[string]spec.Schema{
					"clusterName": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of the cluster.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "The current status.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the desired size of the Coherence cluster.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "CurrentReplicas is the current size of the Coherence cluster.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadyReplicas is the number of Pods created by the StatefulSet.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "label query over pods that should match the replicas count. This is same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"replicas", "currentReplicas", "readyReplicas"},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_CoherenceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "The Coherence specific configuration.",
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"storageEnabled": {
						SchemaProps: spec.SchemaProps{
							Description: "A boolean flag indicating whether members of this role are storage enabled. This value will set the corresponding coherence.distributed.localstorage System property. If not specified the default value is true. This flag is also used to configure the ScalingPolicy value if a value is not specified. If the StorageEnabled field is not specified or is true the scaling will be safe, if StorageEnabled is set to false scaling will be parallel.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"cacheConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "CacheConfig is the name of the cache configuration file to use",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overrideConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "OverrideConfig is name of the Coherence operational configuration override file, the default is tangosol-coherence-override.xml",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "The Coherence log level, default being 5 (info level).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"persistence": {
						SchemaProps: spec.SchemaProps{
							Description: "Persistence values configure the on-disc data persistence settings. The bool Enabled enables or disabled on disc persistence of data.",
							Ref:         ref("./pkg/apis/coherence/v1.PersistentStorageSpec"),
						},
					},
					"snapshot": {
						SchemaProps: spec.SchemaProps{
							Description: "Snapshot values configure the on-disc persistence data snapshot (backup) settings. The bool Enabled enables or disabled a different location for persistence snapshot data. If set to false then snapshot files will be written to the same volume configured for persistence data in the Persistence section.",
							Ref:         ref("./pkg/apis/coherence/v1.PersistentStorageSpec"),
						},
					},
					"management": {
						SchemaProps: spec.SchemaProps{
							Description: "Management configures Coherence management over REST\n  Note: Coherence management over REST will be available in 12.2.1.4.",
							Ref:         ref("./pkg/apis/coherence/v1.PortSpecWithSSL"),
						},
					},
					"metrics": {
						SchemaProps: spec.SchemaProps{
							Description: "Metrics configures Coherence metrics publishing\n  Note: Coherence metrics publishing will be available in 12.2.1.4.",
							Ref:         ref("./pkg/apis/coherence/v1.PortSpecWithSSL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.PersistentStorageSpec", "./pkg/apis/coherence/v1.PortSpecWithSSL"},
	}
}

func schema_pkg_apis_coherence_v1_FluentdSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FluentdSpec defines the settings for the fluentd image",
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Controls whether or not log capture via a Fluentd sidecar container to an EFK stack is enabled. If this flag i set to true it is expected that the coherence-monitoring-config secret exists in the namespace that the cluster is being deployed to. This secret is either created by the Coherence Operator Helm chart if it was installed with the correct parameters or it should have already been created manually.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"configFile": {
						SchemaProps: spec.SchemaProps{
							Description: "The Fluentd configuration file configuring source for application log.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tag": {
						SchemaProps: spec.SchemaProps{
							Description: "This value should be source.tag from fluentd.application.configFile.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_ImageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CoherenceInternalImageSpec defines the settings for a Docker image",
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_JVMSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "The JVM configuration.",
				Properties: map[string]spec.Schema{
					"args": {
						SchemaProps: spec.SchemaProps{
							Description: "Args specifies the options (System properties, -XX: args etc) to pass to the JVM.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"debug": {
						SchemaProps: spec.SchemaProps{
							Description: "The settings for enabling debug mode in the JVM.",
							Ref:         ref("./pkg/apis/coherence/v1.JvmDebugSpec"),
						},
					},
					"useContainerLimits": {
						SchemaProps: spec.SchemaProps{
							Description: "If set to true Adds the  -XX:+UseContainerSupport JVM option to ensure that the JVM respects any container resource limits. The default value is true",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"flightRecorder": {
						SchemaProps: spec.SchemaProps{
							Description: "If set to true, enabled continuour flight recorder recordings. This will add the JVM options -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=/dumps",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"gc": {
						SchemaProps: spec.SchemaProps{
							Description: "Set JVM garbage collector options.",
							Ref:         ref("./pkg/apis/coherence/v1.JvmGarbageCollectorSpec"),
						},
					},
					"diagnosticsVolume": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/api/core/v1.VolumeSource"),
						},
					},
					"memory": {
						SchemaProps: spec.SchemaProps{
							Description: "Configure the JVM memory options.",
							Ref:         ref("./pkg/apis/coherence/v1.JvmMemorySpec"),
						},
					},
					"jmxmp": {
						SchemaProps: spec.SchemaProps{
							Description: "Configure JMX using JMXMP.",
							Ref:         ref("./pkg/apis/coherence/v1.JvmJmxmpSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.JvmDebugSpec", "./pkg/apis/coherence/v1.JvmGarbageCollectorSpec", "./pkg/apis/coherence/v1.JvmJmxmpSpec", "./pkg/apis/coherence/v1.JvmMemorySpec", "k8s.io/api/core/v1.VolumeSource"},
	}
}

func schema_pkg_apis_coherence_v1_JvmDebugSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "The JVM Debug specific configuration. See:",
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled is a flag to enable or disable running the JVM in debug mode. Default is disabled.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"suspend": {
						SchemaProps: spec.SchemaProps{
							Description: "A boolean true if the target VM is to be suspended immediately before the main class is loaded; false otherwise. The default value is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"attach": {
						SchemaProps: spec.SchemaProps{
							Description: "Attach specifies the address of the debugger that the JVM should attempt to connect back to instead of listening on a port.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "The port that the debugger will listen on; the default is 5005.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_LoggingSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LoggingSpec defines the settings for the Coherence Pod logging",
				Properties: map[string]spec.Schema{
					"configFile": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigFile allows the location of the Java util logging configuration file to be overridden.\n If this value is not set the logging.properties file embedded in this chart will be used.\n If this value is set the configuration will be located by trying the following locations in order:\n   1. If store.logging.configMapName is set then the config map will be mounted as a volume and the logging\n        properties file will be located as a file location relative to the ConfigMap volume mount point.\n   2. If userArtifacts.imageName is set then using this value as a file name relative to the location of the\n        configuration files directory in the user artifacts image.\n   3. Using this value as an absolute file name.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configMapName": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMapName allows a config map to be mounted as a volume containing the logging\n configuration file to use.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fluentd": {
						SchemaProps: spec.SchemaProps{
							Description: "Configures whether Fluentd is enabled and the configuration of the Fluentd side-car container",
							Ref:         ref("./pkg/apis/coherence/v1.FluentdSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.FluentdSpec"},
	}
}

func schema_pkg_apis_coherence_v1_NamedPortSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "----- NamedPortSpec struct ---------------------------------------------------- NamedPortSpec defines a named port for a Coherence component",
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name specifies the name of th port.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port specifies the port used.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"protocol": {
						SchemaProps: spec.SchemaProps{
							Description: "Protocol for container port. Must be UDP or TCP. Defaults to \"TCP\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"service": {
						SchemaProps: spec.SchemaProps{
							Description: "Service specifies the service used to expose the port.",
							Ref:         ref("./pkg/apis/coherence/v1.ServiceSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.ServiceSpec"},
	}
}

func schema_pkg_apis_coherence_v1_PersistentStorageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PersistenceStorageSpec defines the persistence settings for the Coherence",
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"boolean"},
							Format: "",
						},
					},
					"persistentVolumeClaim": {
						SchemaProps: spec.SchemaProps{
							Description: "PersistentVolumeClaim allows the configuration of a normal k8s persistent volume claim for persistence data.",
							Ref:         ref("k8s.io/api/core/v1.PersistentVolumeClaimSpec"),
						},
					},
					"volume": {
						SchemaProps: spec.SchemaProps{
							Description: "Volume allows the configuration of a normal k8s volume mapping for persistence data instead of a persistent volume claim. If a value is defined for store.persistence.volume then no PVC will be created and persistence data will instead be written to this volume. It is up to the deployer to understand the consequences of this and how the guarantees given when using PVCs differ to the storage guarantees for the particular volume type configured here.",
							Ref:         ref("k8s.io/api/core/v1.VolumeSource"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.PersistentVolumeClaimSpec", "k8s.io/api/core/v1.VolumeSource"},
	}
}

func schema_pkg_apis_coherence_v1_PortSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "----- PortSpec struct ---------------------------------------------------- PortSpec defines the port settings for a Coherence component",
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port specifies the port used.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"protocol": {
						SchemaProps: spec.SchemaProps{
							Description: "Protocol for container port. Must be UDP or TCP. Defaults to \"TCP\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"service": {
						SchemaProps: spec.SchemaProps{
							Description: "Service specifies the service used to expose the port.",
							Ref:         ref("./pkg/apis/coherence/v1.ServiceSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.ServiceSpec"},
	}
}

func schema_pkg_apis_coherence_v1_PortSpecWithSSL(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PortSpecWithSSL defines a port with SSL settings for a Coherence component",
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enable or disable flag.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "The port to bind to.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"ssl": {
						SchemaProps: spec.SchemaProps{
							Description: "SSL configures SSL settings for a Coherence component",
							Ref:         ref("./pkg/apis/coherence/v1.SSLSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./pkg/apis/coherence/v1.SSLSpec"},
	}
}

func schema_pkg_apis_coherence_v1_ReadinessProbeSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ReadinessProbeSpec defines the settings for the Coherence Pod readiness probe",
				Properties: map[string]spec.Schema{
					"exec": {
						SchemaProps: spec.SchemaProps{
							Description: "One and only one of the following should be specified. Exec specifies the action to take.",
							Ref:         ref("k8s.io/api/core/v1.ExecAction"),
						},
					},
					"httpGet": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTPGet specifies the http request to perform.",
							Ref:         ref("k8s.io/api/core/v1.HTTPGetAction"),
						},
					},
					"tcpSocket": {
						SchemaProps: spec.SchemaProps{
							Description: "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported",
							Ref:         ref("k8s.io/api/core/v1.TCPSocketAction"),
						},
					},
					"initialDelaySeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"periodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "How often (in seconds) to perform the probe.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"successThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum consecutive successes for the probe to be considered successful after having failed.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failureThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum consecutive failures for the probe to be considered failed after having succeeded.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ExecAction", "k8s.io/api/core/v1.HTTPGetAction", "k8s.io/api/core/v1.TCPSocketAction"},
	}
}

func schema_pkg_apis_coherence_v1_SSLSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SSLSpec defines the SSL settings for a Coherence component over REST endpoint.",
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled is a boolean flag indicating whether enables or disables SSL on the Coherence management over REST endpoint, the default is false (disabled).",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"secrets": {
						SchemaProps: spec.SchemaProps{
							Description: "Secrets is the name of the k8s secrets containing the Java key stores and password files.\n  This value MUST be provided if SSL is enabled on the Coherence management over ReST endpoint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keyStore": {
						SchemaProps: spec.SchemaProps{
							Description: "Keystore is the name of the Java key store file in the k8s secret to use as the SSL keystore\n  when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keyStorePasswordFile": {
						SchemaProps: spec.SchemaProps{
							Description: "KeyStorePasswordFile is the name of the file in the k8s secret containing the keystore\n  password when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keyPasswordFile": {
						SchemaProps: spec.SchemaProps{
							Description: "KeyStorePasswordFile is the name of the file in the k8s secret containing the key\n  password when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keyStoreAlgorithm": {
						SchemaProps: spec.SchemaProps{
							Description: "KeyStoreAlgorithm is the name of the keystore algorithm for the keystore in the k8s secret\n  used when configuring component over REST to use SSL. If not set the default is SunX509",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keyStoreProvider": {
						SchemaProps: spec.SchemaProps{
							Description: "KeyStoreProvider is the name of the keystore provider for the keystore in the k8s secret\n  used when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"keyStoreType": {
						SchemaProps: spec.SchemaProps{
							Description: "KeyStoreType is the name of the Java keystore type for the keystore in the k8s secret used\n  when configuring component over REST to use SSL. If not set the default is JKS.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"trustStore": {
						SchemaProps: spec.SchemaProps{
							Description: "TrustStore is the name of the Java trust store file in the k8s secret to use as the SSL\n  trust store when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"trustStorePasswordFile": {
						SchemaProps: spec.SchemaProps{
							Description: "TrustStorePasswordFile is the name of the file in the k8s secret containing the trust store\n  password when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"trustStoreAlgorithm": {
						SchemaProps: spec.SchemaProps{
							Description: "TrustStoreAlgorithm is the name of the keystore algorithm for the trust store in the k8s\n  secret used when configuring component over REST to use SSL.  If not set the default is SunX509.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"trustStoreProvider": {
						SchemaProps: spec.SchemaProps{
							Description: "TrustStoreProvider is the name of the keystore provider for the trust store in the k8s\n  secret used when configuring component over REST to use SSL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"trustStoreType": {
						SchemaProps: spec.SchemaProps{
							Description: "TrustStoreType is the name of the Java keystore type for the trust store in the k8s secret\n  used when configuring component over REST to use SSL. If not set the default is JKS.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"requireClientCert": {
						SchemaProps: spec.SchemaProps{
							Description: "RequireClientCert is a boolean flag indicating whether the client certificate will be\n  authenticated by the server (two-way SSL) when configuring component over REST to use SSL.\n  If not set the default is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{},
	}
}

func schema_pkg_apis_coherence_v1_ScalingProbe(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ScalingProbe is the handler that will be used to determine how to check for StatusHA in a CoherenceRole. StatusHA checking is primarily used during scaling of a role, a role must be in a safe Status HA state before scaling takes place. If StatusHA handler is disabled for a role (by specifically setting Enabled to false then no check will take place and a role will be assumed to be safe).",
				Properties: map[string]spec.Schema{
					"exec": {
						SchemaProps: spec.SchemaProps{
							Description: "One and only one of the following should be specified. Exec specifies the action to take.",
							Ref:         ref("k8s.io/api/core/v1.ExecAction"),
						},
					},
					"httpGet": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTPGet specifies the http request to perform.",
							Ref:         ref("k8s.io/api/core/v1.HTTPGetAction"),
						},
					},
					"tcpSocket": {
						SchemaProps: spec.SchemaProps{
							Description: "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported",
							Ref:         ref("k8s.io/api/core/v1.TCPSocketAction"),
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of seconds after which the handler times out (only applies to http and tcp handlers). Defaults to 1 second. Minimum value is 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ExecAction", "k8s.io/api/core/v1.HTTPGetAction", "k8s.io/api/core/v1.TCPSocketAction"},
	}
}

func schema_pkg_apis_coherence_v1_ServiceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "----- ServiceSpec struct ------------------------------------------------- ServiceSpec defines the settings for a Service",
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether to create the service yaml or not",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "An optional name to use to override the generated service name.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "The service port value",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type is the K8s service type (typically ClusterIP or LoadBalancer) The default is \"ClusterIP\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"loadBalancerIP": {
						SchemaProps: spec.SchemaProps{
							Description: "LoadBalancerIP is the IP address of the load balancer",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "The extra labels to add to the service. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations is free form yaml that will be added to the service annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"sessionAffinity": {
						SchemaProps: spec.SchemaProps{
							Description: "Supports \"ClientIP\" and \"None\". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"loadBalancerSourceRanges": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.\" More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"externalName": {
						SchemaProps: spec.SchemaProps{
							Description: "externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"externalTrafficPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. \"Local\" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. \"Cluster\" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"healthCheckNodePort": {
						SchemaProps: spec.SchemaProps{
							Description: "healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"publishNotReadyAddresses": {
						SchemaProps: spec.SchemaProps{
							Description: "publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"sessionAffinityConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "sessionAffinityConfig contains the configurations of session affinity.",
							Ref:         ref("k8s.io/api/core/v1.SessionAffinityConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SessionAffinityConfig"},
	}
}
